// LiveKit Voice Assistant Service for React Native
// Real-time voice AI conversations powered by LiveKit Agents

import * as LiveKitService from './livekitService';

class LiveKitVoiceAssistantService {
  constructor() {
    this.room = null;
    this.isConnected = false;
    this.conversationHistory = [];
    this.listeners = {
      onCallStart: null,
      onCallEnd: null,
      onUserStartSpeaking: null,
      onUserStopSpeaking: null,
      onAssistantStartSpeaking: null,
      onAssistantStopSpeaking: null,
      onMessage: null,
      onError: null,
    };
  }

  /**
   * Initialize LiveKit connection
   * @param {string} token - LiveKit access token (should be generated by backend)
   */
  async initialize(token) {
    try {
      console.log('Initializing LiveKit Voice Assistant...');

      if (!token) {
        throw new Error('LiveKit token is required');
      }

      // Connect to LiveKit room with the AI agent
      this.room = await LiveKitService.connectToRoom(token);

      // Set up event listeners
      this.setupEventListeners();

      this.isConnected = true;
      console.log('LiveKit Voice Assistant initialized successfully');

      if (this.listeners.onCallStart) {
        this.listeners.onCallStart();
      }

      return true;
    } catch (error) {
      console.error('Failed to initialize LiveKit:', error);
      if (this.listeners.onError) {
        this.listeners.onError(error);
      }
      throw error;
    }
  }

  /**
   * Set up LiveKit event listeners
   */
  setupEventListeners() {
    if (!this.room) return;

    // Listen for data messages from the AI agent
    this.room.on('DataReceived', (payload, participant) => {
      const decoder = new TextDecoder();
      const message = decoder.decode(payload);

      console.log('Message received from agent:', message);

      const messageObj = {
        from: participant?.identity || 'agent',
        message: message,
        timestamp: new Date().toISOString(),
      };

      this.conversationHistory.push(messageObj);

      if (this.listeners.onMessage) {
        this.listeners.onMessage(messageObj);
      }
    });

    // Listen for track subscriptions (audio from agent)
    this.room.on('TrackSubscribed', (track, publication, participant) => {
      console.log('Track subscribed:', track.kind, 'from', participant.identity);

      if (track.kind === 'audio') {
        if (this.listeners.onAssistantStartSpeaking) {
          this.listeners.onAssistantStartSpeaking();
        }
      }
    });

    // Listen for track unsubscriptions
    this.room.on('TrackUnsubscribed', (track, publication, participant) => {
      console.log('Track unsubscribed:', track.kind, 'from', participant.identity);

      if (track.kind === 'audio') {
        if (this.listeners.onAssistantStopSpeaking) {
          this.listeners.onAssistantStopSpeaking();
        }
      }
    });

    // Listen for disconnection
    this.room.on('Disconnected', (reason) => {
      console.log('Disconnected from room:', reason);
      this.isConnected = false;
      this.room = null;

      if (this.listeners.onCallEnd) {
        this.listeners.onCallEnd();
      }
    });
  }

  /**
   * Start a voice call with the AI assistant
   * @param {string} token - LiveKit access token
   * @param {object} metadata - Optional metadata/context to pass to the assistant
   */
  async startCall(token, metadata = null) {
    try {
      console.log('Starting LiveKit call...');

      // Initialize the connection
      await this.initialize(token);

      // If metadata provided, send it to the agent
      if (metadata && this.room) {
        await this.sendMessage(JSON.stringify({
          type: 'metadata',
          data: metadata
        }));
        console.log('Metadata sent to agent:', metadata);
      }

      // Enable microphone
      await LiveKitService.toggleMicrophone(true);

      return {
        room: this.room,
        isConnected: true
      };
    } catch (error) {
      console.error('Failed to start call:', error);
      if (this.listeners.onError) {
        this.listeners.onError(error);
      }
      throw error;
    }
  }

  /**
   * End the current call
   */
  async endCall() {
    try {
      if (this.room && this.isConnected) {
        console.log('Ending LiveKit call...');
        await LiveKitService.disconnectFromRoom();
        this.isConnected = false;
        this.room = null;
        console.log('Call ended');

        if (this.listeners.onCallEnd) {
          this.listeners.onCallEnd();
        }
      }
    } catch (error) {
      console.error('Failed to end call:', error);
      if (this.listeners.onError) {
        this.listeners.onError(error);
      }
      throw error;
    }
  }

  /**
   * Toggle mute/unmute
   */
  async toggleMute() {
    try {
      if (this.room && this.isConnected) {
        const currentState = this.room.localParticipant.isMicrophoneEnabled;
        await LiveKitService.toggleMicrophone(!currentState);
        return !currentState;
      }
    } catch (error) {
      console.error('Failed to toggle mute:', error);
      if (this.listeners.onError) {
        this.listeners.onError(error);
      }
    }
  }

  /**
   * Send a message to the AI agent
   */
  async sendMessage(message) {
    try {
      if (this.room && this.isConnected) {
        await LiveKitService.sendDataMessage(message);

        // Add to conversation history
        const messageObj = {
          from: 'user',
          message: message,
          timestamp: new Date().toISOString(),
        };
        this.conversationHistory.push(messageObj);

        console.log('Message sent to agent:', message);
      }
    } catch (error) {
      console.error('Failed to send message:', error);
      if (this.listeners.onError) {
        this.listeners.onError(error);
      }
    }
  }

  /**
   * Set event handlers
   */
  setEventHandlers(handlers) {
    this.listeners = { ...this.listeners, ...handlers };
  }

  // Event handler setters
  onCallStart(callback) {
    this.listeners.onCallStart = callback;
  }

  onCallEnd(callback) {
    this.listeners.onCallEnd = callback;
  }

  onUserStartSpeaking(callback) {
    this.listeners.onUserStartSpeaking = callback;
  }

  onUserStopSpeaking(callback) {
    this.listeners.onUserStopSpeaking = callback;
  }

  onAssistantStartSpeaking(callback) {
    this.listeners.onAssistantStartSpeaking = callback;
  }

  onAssistantStopSpeaking(callback) {
    this.listeners.onAssistantStopSpeaking = callback;
  }

  onMessage(callback) {
    this.listeners.onMessage = callback;
  }

  onError(callback) {
    this.listeners.onError = callback;
  }

  /**
   * Simple start call wrapper for Patient Dashboard
   * @param {string} token - LiveKit access token
   * @param {object} memoryContext - Optional memory context to discuss
   */
  async startVoiceConversation(token, memoryContext = null) {
    try {
      console.log('Starting voice conversation with LiveKit...');

      // Prepare metadata if memory context is provided
      const metadata = memoryContext ? {
        memoryContext: {
          title: memoryContext.title,
          time: memoryContext.time,
          type: memoryContext.type,
          strength: memoryContext.strength
        }
      } : null;

      const result = await this.startCall(token, metadata);

      return {
        isConnected: true,
        room: result.room
      };
    } catch (error) {
      console.error('Voice conversation failed:', error);
      if (this.listeners.onError) {
        this.listeners.onError(error);
      }
      throw error;
    }
  }

  /**
   * Stop the conversation
   */
  async stopVoiceConversation() {
    try {
      await this.endCall();
      this.conversationHistory = [];
      return true;
    } catch (error) {
      console.error('Failed to stop conversation:', error);
      if (this.listeners.onError) {
        this.listeners.onError(error);
      }
      throw error;
    }
  }

  /**
   * Get conversation history
   */
  getConversationHistory() {
    return this.conversationHistory;
  }

  /**
   * Clear conversation history
   */
  clearHistory() {
    this.conversationHistory = [];
  }

  /**
   * Get current connection status
   */
  getConnectionStatus() {
    return {
      isConnected: this.isConnected,
      room: this.room,
    };
  }
}

export default new LiveKitVoiceAssistantService();
